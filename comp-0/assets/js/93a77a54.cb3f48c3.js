"use strict";(globalThis.webpackChunkgithub_docs=globalThis.webpackChunkgithub_docs||[]).push([[2368],{4377:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"fastapi/examples/scenario-09-booking-system","title":"\uc2dc\ub098\ub9ac\uc624 9: \uc608\uc57d \uc2dc\uc2a4\ud15c","description":"\ud638\ud154/\ub808\uc2a4\ud1a0\ub791/\ud68c\uc758\uc2e4 \uc608\uc57d \uc2dc\uc2a4\ud15c\uc744 \ub9cc\ub4e4\uc5b4\ubd05\uc2dc\ub2e4!","source":"@site/docs/fastapi/examples/scenario-09-booking-system.md","sourceDirName":"fastapi/examples","slug":"/fastapi/examples/scenario-09-booking-system","permalink":"/docs/fastapi/examples/scenario-09-booking-system","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/fastapi/examples/scenario-09-booking-system.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"fastapiSidebar","previous":{"title":"\uc2dc\ub098\ub9ac\uc624 8: \uc18c\uc15c \ubbf8\ub514\uc5b4 API","permalink":"/docs/fastapi/examples/scenario-08-social-media"},"next":{"title":"\uc2dc\ub098\ub9ac\uc624 10: \uc54c\ub9bc \uc2dc\uc2a4\ud15c","permalink":"/docs/fastapi/examples/scenario-10-notification-system"}}');var o=t(4848),s=t(8453);const r={sidebar_position:10},a="\uc2dc\ub098\ub9ac\uc624 9: \uc608\uc57d \uc2dc\uc2a4\ud15c",d={},l=[{value:"\ud83d\udccc \uae30\ub2a5",id:"-\uae30\ub2a5",level:2},{value:"\ud83d\udcc1 \ud504\ub85c\uc81d\ud2b8 \uad6c\uc870",id:"-\ud504\ub85c\uc81d\ud2b8-\uad6c\uc870",level:2},{value:"\ud83d\udcca \uc2dc\ud000\uc2a4 \ub2e4\uc774\uc5b4\uadf8\ub7a8",id:"-\uc2dc\ud000\uc2a4-\ub2e4\uc774\uc5b4\uadf8\ub7a8",level:2},{value:"\ud83d\udcdd \ud575\uc2ec \ucf54\ub4dc",id:"-\ud575\uc2ec-\ucf54\ub4dc",level:2},{value:"models.py",id:"modelspy",level:3},{value:"booking_service.py",id:"booking_servicepy",level:3},{value:"main.py",id:"mainpy",level:3},{value:"\ud83d\udd11 \ud575\uc2ec \uac1c\ub150",id:"-\ud575\uc2ec-\uac1c\ub150",level:2},{value:"\uc911\ubcf5 \uc608\uc57d \ubc29\uc9c0",id:"\uc911\ubcf5-\uc608\uc57d-\ubc29\uc9c0",level:3},{value:"\uc6b4\uc601 \uc2dc\uac04 \uac80\uc99d",id:"\uc6b4\uc601-\uc2dc\uac04-\uac80\uc99d",level:3},{value:"\ub300\uae30\uc5f4 \uc2dc\uc2a4\ud15c",id:"\ub300\uae30\uc5f4-\uc2dc\uc2a4\ud15c",level:3},{value:"\ub9ac\ub9c8\uc778\ub354",id:"\ub9ac\ub9c8\uc778\ub354",level:3},{value:"\ud83d\udcda \ub2e4\uc74c \ub2e8\uacc4",id:"-\ub2e4\uc74c-\ub2e8\uacc4",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"\uc2dc\ub098\ub9ac\uc624-9-\uc608\uc57d-\uc2dc\uc2a4\ud15c",children:"\uc2dc\ub098\ub9ac\uc624 9: \uc608\uc57d \uc2dc\uc2a4\ud15c"})}),"\n",(0,o.jsx)(n.p,{children:"\ud638\ud154/\ub808\uc2a4\ud1a0\ub791/\ud68c\uc758\uc2e4 \uc608\uc57d \uc2dc\uc2a4\ud15c\uc744 \ub9cc\ub4e4\uc5b4\ubd05\uc2dc\ub2e4!"}),"\n",(0,o.jsx)(n.h2,{id:"-\uae30\ub2a5",children:"\ud83d\udccc \uae30\ub2a5"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"\u2705 \uc2dc\uac04\ub300\ubcc4 \uc608\uc57d \uac00\ub2a5 \uc5ec\ubd80 \ud655\uc778"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 \uc911\ubcf5 \uc608\uc57d \ubc29\uc9c0"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 \uc608\uc57d \uc0dd\uc131/\uc218\uc815/\ucde8\uc18c"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 \ub300\uae30\uc5f4 \uad00\ub9ac"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 \uc790\ub3d9 \ud655\uc778 \ubc0f \uc54c\ub9bc"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 \ub178\uc1fc(No-show) \ucc98\ub9ac"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 \ub9ac\ub9c8\uc778\ub354 \ubc1c\uc1a1"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-\ud504\ub85c\uc81d\ud2b8-\uad6c\uc870",children:"\ud83d\udcc1 \ud504\ub85c\uc81d\ud2b8 \uad6c\uc870"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"booking-system/\n\u251c\u2500\u2500 main.py                 # FastAPI \uc560\ud50c\ub9ac\ucf00\uc774\uc158\n\u251c\u2500\u2500 models.py               # DB \ubaa8\ub378 (Resource, Booking, Waitlist)\n\u251c\u2500\u2500 schemas.py              # Pydantic \uc2a4\ud0a4\ub9c8\n\u251c\u2500\u2500 database.py             # \ub370\uc774\ud130\ubca0\uc774\uc2a4 \uc5f0\uacb0\n\u251c\u2500\u2500 booking_service.py      # \uc608\uc57d \ube44\uc988\ub2c8\uc2a4 \ub85c\uc9c1\n\u251c\u2500\u2500 availability_checker.py # \uac00\uc6a9\uc131 \ud655\uc778\n\u251c\u2500\u2500 reminder_scheduler.py   # \ub9ac\ub9c8\uc778\ub354 \uc2a4\ucf00\uc904\ub7ec\n\u2514\u2500\u2500 requirements.txt        # \uc758\uc874\uc131 \ud328\ud0a4\uc9c0\n"})}),"\n",(0,o.jsx)(n.h2,{id:"-\uc2dc\ud000\uc2a4-\ub2e4\uc774\uc5b4\uadf8\ub7a8",children:"\ud83d\udcca \uc2dc\ud000\uc2a4 \ub2e4\uc774\uc5b4\uadf8\ub7a8"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant U as User\n    participant API as FastAPI\n    participant BS as BookingService\n    participant AC as AvailabilityChecker\n    participant RS as ReminderScheduler\n    participant DB as Database\n\n    Note over U,DB: 1. \uac00\uc6a9\uc131 \ud655\uc778\n    U->>API: GET /resources/{id}/availability<br/>?date=2024-01-01&duration=2h\n    API->>AC: check_availability()\n    AC->>DB: SELECT bookings<br/>WHERE resource_id AND<br/>time overlaps\n    DB--\x3e>AC: Existing bookings\n    AC->>AC: Calculate free slots\n    AC--\x3e>API: Available time slots\n    API--\x3e>U: 200 OK + Available slots\n\n    Note over U,DB: 2. \uc608\uc57d \uc0dd\uc131 (\ub099\uad00\uc801 \uc7a0\uae08)\n    U->>API: POST /bookings<br/>{resource_id, start_time, end_time}\n    API->>BS: create_booking()\n    BS->>DB: BEGIN TRANSACTION\n    BS->>DB: SELECT bookings FOR UPDATE<br/>WHERE resource_id AND time overlaps\n    DB--\x3e>BS: Lock acquired + bookings\n    alt Time slot available\n        BS->>DB: INSERT booking (status=pending)\n        BS->>DB: COMMIT\n        DB--\x3e>BS: Booking created\n        BS->>RS: schedule_reminder()\n        RS->>RS: Add to job queue\n        BS--\x3e>API: Booking confirmed\n        API--\x3e>U: 201 Created + Booking\n    else Time slot taken\n        BS->>DB: ROLLBACK\n        BS--\x3e>API: Slot unavailable\n        API--\x3e>U: 409 Conflict\n    end\n\n    Note over U,DB: 3. \ub300\uae30\uc5f4 \ucd94\uac00\n    U->>API: POST /bookings/{id}/waitlist\n    API->>DB: INSERT INTO waitlist\n    DB--\x3e>API: Waitlist entry\n    API--\x3e>U: 200 OK + Position in queue\n\n    Note over U,DB: 4. \uc608\uc57d \ucde8\uc18c & \ub300\uae30\uc5f4 \ucc98\ub9ac\n    U->>API: DELETE /bookings/{id}\n    API->>BS: cancel_booking()\n    BS->>DB: UPDATE booking (status=cancelled)\n    BS->>DB: SELECT waitlist<br/>WHERE resource_id<br/>ORDER BY created_at\n    DB--\x3e>BS: Waitlist entries\n    alt Waitlist not empty\n        BS->>BS: Process first in waitlist\n        BS->>DB: INSERT new booking\n        BS->>DB: DELETE from waitlist\n        BS->>API: Notify waitlisted user\n    end\n    BS--\x3e>API: Cancelled\n    API--\x3e>U: 204 No Content\n\n    Note over U,DB: 5. \ub9ac\ub9c8\uc778\ub354 \ubc1c\uc1a1 (\ubc31\uadf8\ub77c\uc6b4\ub4dc)\n    RS->>RS: Check scheduled reminders\n    RS->>DB: SELECT bookings<br/>WHERE start_time - 24h = now()\n    DB--\x3e>RS: Bookings to remind\n    loop For each booking\n        RS->>RS: Send email/SMS reminder\n        RS->>DB: UPDATE last_reminder_sent\n    end\n"})}),"\n",(0,o.jsx)(n.h2,{id:"-\ud575\uc2ec-\ucf54\ub4dc",children:"\ud83d\udcdd \ud575\uc2ec \ucf54\ub4dc"}),"\n",(0,o.jsx)(n.h3,{id:"modelspy",children:"models.py"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Enum as SQLEnum, Float, CheckConstraint\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom database import Base\nimport enum\nfrom datetime import datetime, timedelta\n\nclass BookingStatus(str, enum.Enum):\n    pending = "pending"\n    confirmed = "confirmed"\n    cancelled = "cancelled"\n    completed = "completed"\n    no_show = "no_show"\n\nclass ResourceType(str, enum.Enum):\n    hotel_room = "hotel_room"\n    restaurant_table = "restaurant_table"\n    meeting_room = "meeting_room"\n    parking_spot = "parking_spot"\n\nclass Resource(Base):\n    """\uc608\uc57d \uac00\ub2a5\ud55c \uc790\uc6d0 (\ud638\ud154 \ubc29, \ud14c\uc774\ube14 \ub4f1)"""\n    __tablename__ = "resources"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String, index=True)\n    type = Column(SQLEnum(ResourceType))\n    capacity = Column(Integer)  # \uc218\uc6a9 \uc778\uc6d0\n    description = Column(String, nullable=True)\n\n    # \uac00\uaca9\n    price_per_hour = Column(Float, nullable=True)\n    price_per_day = Column(Float, nullable=True)\n\n    # \uc608\uc57d \uc124\uc815\n    min_duration_minutes = Column(Integer, default=60)\n    max_duration_minutes = Column(Integer, default=480)\n    advance_booking_days = Column(Integer, default=30)  # \ucd5c\ub300 \uba70\uce60 \uc804\uae4c\uc9c0 \uc608\uc57d \uac00\ub2a5\n\n    # \uc6b4\uc601 \uc2dc\uac04\n    open_time = Column(String, default="09:00")  # HH:MM\n    close_time = Column(String, default="18:00")\n\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    bookings = relationship("Booking", back_populates="resource")\n    availability_rules = relationship("AvailabilityRule", back_populates="resource")\n\nclass AvailabilityRule(Base):\n    """\ud2b9\uc815 \uc790\uc6d0\uc758 \uc0ac\uc6a9 \ubd88\uac00 \uc2dc\uac04"""\n    __tablename__ = "availability_rules"\n\n    id = Column(Integer, primary_key=True)\n    resource_id = Column(Integer, ForeignKey(\'resources.id\'), index=True)\n    start_datetime = Column(DateTime(timezone=True), index=True)\n    end_datetime = Column(DateTime(timezone=True))\n    reason = Column(String)  # "maintenance", "reserved", "blocked"\n\n    resource = relationship("Resource", back_populates="availability_rules")\n\nclass Booking(Base):\n    __tablename__ = "bookings"\n\n    id = Column(Integer, primary_key=True)\n    resource_id = Column(Integer, ForeignKey(\'resources.id\'), index=True)\n    user_id = Column(Integer, ForeignKey(\'users.id\'), index=True)\n\n    # \uc608\uc57d \uc2dc\uac04\n    start_datetime = Column(DateTime(timezone=True), index=True)\n    end_datetime = Column(DateTime(timezone=True), index=True)\n\n    # \uc608\uc57d \uc815\ubcf4\n    guest_name = Column(String)\n    guest_email = Column(String)\n    guest_phone = Column(String)\n    guest_count = Column(Integer)\n\n    # \uc0c1\ud0dc\n    status = Column(SQLEnum(BookingStatus), default=BookingStatus.pending, index=True)\n\n    # \uac00\uaca9\n    total_price = Column(Float)\n\n    # \ud2b9\ubcc4 \uc694\uccad\n    special_requests = Column(String, nullable=True)\n\n    # \ud0c0\uc784\uc2a4\ud0ec\ud504\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    confirmed_at = Column(DateTime(timezone=True), nullable=True)\n    cancelled_at = Column(DateTime(timezone=True), nullable=True)\n    cancellation_reason = Column(String, nullable=True)\n\n    # \uc54c\ub9bc\n    reminder_sent = Column(Boolean, default=False)\n\n    # \uad00\uacc4\n    resource = relationship("Resource", back_populates="bookings")\n    user = relationship("User")\n\n    __table_args__ = (\n        CheckConstraint(\'end_datetime > start_datetime\', name=\'check_valid_time_range\'),\n    )\n\nclass WaitList(Base):\n    """\ub300\uae30\uc5f4"""\n    __tablename__ = "waitlist"\n\n    id = Column(Integer, primary_key=True)\n    resource_id = Column(Integer, ForeignKey(\'resources.id\'), index=True)\n    user_id = Column(Integer, ForeignKey(\'users.id\'))\n\n    desired_start = Column(DateTime(timezone=True))\n    desired_end = Column(DateTime(timezone=True))\n    guest_count = Column(Integer)\n\n    notified = Column(Boolean, default=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n\n    resource = relationship("Resource")\n    user = relationship("User")\n'})}),"\n",(0,o.jsx)(n.h3,{id:"booking_servicepy",children:"booking_service.py"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_\nfrom fastapi import HTTPException\nfrom datetime import datetime, timedelta\nimport models\n\nclass BookingService:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def check_availability(\n        self,\n        resource_id: int,\n        start_datetime: datetime,\n        end_datetime: datetime\n    ) -> bool:\n        """\uc608\uc57d \uac00\ub2a5 \uc5ec\ubd80 \ud655\uc778"""\n        # \uc790\uc6d0 \uc874\uc7ac \ud655\uc778\n        resource = self.db.query(models.Resource).filter(\n            models.Resource.id == resource_id,\n            models.Resource.is_active == True\n        ).first()\n\n        if not resource:\n            raise HTTPException(status_code=404, detail="Resource not found")\n\n        # \uc2dc\uac04 \uac80\uc99d\n        if end_datetime <= start_datetime:\n            raise HTTPException(status_code=400, detail="Invalid time range")\n\n        # \ucd5c\uc18c/\ucd5c\ub300 \uc608\uc57d \uc2dc\uac04 \uac80\uc99d\n        duration_minutes = (end_datetime - start_datetime).total_seconds() / 60\n        if duration_minutes < resource.min_duration_minutes:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Minimum booking duration is {resource.min_duration_minutes} minutes"\n            )\n        if duration_minutes > resource.max_duration_minutes:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Maximum booking duration is {resource.max_duration_minutes} minutes"\n            )\n\n        # \ucd5c\ub300 \uc0ac\uc804 \uc608\uc57d \uae30\uac04 \ud655\uc778\n        days_advance = (start_datetime.date() - datetime.now().date()).days\n        if days_advance > resource.advance_booking_days:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Can only book up to {resource.advance_booking_days} days in advance"\n            )\n\n        # \uc6b4\uc601 \uc2dc\uac04 \ud655\uc778\n        if not self._is_within_operating_hours(resource, start_datetime, end_datetime):\n            raise HTTPException(\n                status_code=400,\n                detail=f"Outside operating hours ({resource.open_time} - {resource.close_time})"\n            )\n\n        # \uc911\ubcf5 \uc608\uc57d \ud655\uc778\n        overlap = self.db.query(models.Booking).filter(\n            models.Booking.resource_id == resource_id,\n            models.Booking.status.in_([\n                models.BookingStatus.pending,\n                models.BookingStatus.confirmed\n            ]),\n            or_(\n                # \uc0c8 \uc608\uc57d\uc758 \uc2dc\uc791\uc774 \uae30\uc874 \uc608\uc57d \uc2dc\uac04 \ub0b4\uc5d0 \uc788\ub294 \uacbd\uc6b0\n                and_(\n                    models.Booking.start_datetime <= start_datetime,\n                    models.Booking.end_datetime > start_datetime\n                ),\n                # \uc0c8 \uc608\uc57d\uc758 \uc885\ub8cc\uac00 \uae30\uc874 \uc608\uc57d \uc2dc\uac04 \ub0b4\uc5d0 \uc788\ub294 \uacbd\uc6b0\n                and_(\n                    models.Booking.start_datetime < end_datetime,\n                    models.Booking.end_datetime >= end_datetime\n                ),\n                # \uc0c8 \uc608\uc57d\uc774 \uae30\uc874 \uc608\uc57d\uc744 \uc644\uc804\ud788 \ud3ec\ud568\ud558\ub294 \uacbd\uc6b0\n                and_(\n                    models.Booking.start_datetime >= start_datetime,\n                    models.Booking.end_datetime <= end_datetime\n                )\n            )\n        ).first()\n\n        if overlap:\n            return False\n\n        # \uc0ac\uc6a9 \ubd88\uac00 \uc2dc\uac04 \ud655\uc778\n        blocked = self.db.query(models.AvailabilityRule).filter(\n            models.AvailabilityRule.resource_id == resource_id,\n            or_(\n                and_(\n                    models.AvailabilityRule.start_datetime <= start_datetime,\n                    models.AvailabilityRule.end_datetime > start_datetime\n                ),\n                and_(\n                    models.AvailabilityRule.start_datetime < end_datetime,\n                    models.AvailabilityRule.end_datetime >= end_datetime\n                )\n            )\n        ).first()\n\n        if blocked:\n            return False\n\n        return True\n\n    def _is_within_operating_hours(\n        self,\n        resource: models.Resource,\n        start_datetime: datetime,\n        end_datetime: datetime\n    ) -> bool:\n        """\uc6b4\uc601 \uc2dc\uac04 \ub0b4\uc778\uc9c0 \ud655\uc778"""\n        open_hour, open_minute = map(int, resource.open_time.split(\':\'))\n        close_hour, close_minute = map(int, resource.close_time.split(\':\'))\n\n        start_time = start_datetime.time()\n        end_time = end_datetime.time()\n\n        from datetime import time\n        open_time = time(open_hour, open_minute)\n        close_time = time(close_hour, close_minute)\n\n        return start_time >= open_time and end_time <= close_time\n\n    def calculate_price(\n        self,\n        resource: models.Resource,\n        start_datetime: datetime,\n        end_datetime: datetime\n    ) -> float:\n        """\uac00\uaca9 \uacc4\uc0b0"""\n        duration_hours = (end_datetime - start_datetime).total_seconds() / 3600\n\n        if resource.price_per_hour:\n            return resource.price_per_hour * duration_hours\n        elif resource.price_per_day:\n            days = (end_datetime.date() - start_datetime.date()).days + 1\n            return resource.price_per_day * days\n        else:\n            return 0.0\n\n    def create_booking(\n        self,\n        resource_id: int,\n        user_id: int,\n        start_datetime: datetime,\n        end_datetime: datetime,\n        guest_name: str,\n        guest_email: str,\n        guest_phone: str,\n        guest_count: int,\n        special_requests: str = None\n    ) -> models.Booking:\n        """\uc608\uc57d \uc0dd\uc131"""\n        # \uac00\uc6a9\uc131 \ud655\uc778\n        if not self.check_availability(resource_id, start_datetime, end_datetime):\n            raise HTTPException(status_code=409, detail="Time slot not available")\n\n        resource = self.db.query(models.Resource).filter(\n            models.Resource.id == resource_id\n        ).first()\n\n        # \uc218\uc6a9 \uc778\uc6d0 \ud655\uc778\n        if guest_count > resource.capacity:\n            raise HTTPException(\n                status_code=400,\n                detail=f"Resource capacity is {resource.capacity}"\n            )\n\n        # \uac00\uaca9 \uacc4\uc0b0\n        total_price = self.calculate_price(resource, start_datetime, end_datetime)\n\n        # \uc608\uc57d \uc0dd\uc131\n        booking = models.Booking(\n            resource_id=resource_id,\n            user_id=user_id,\n            start_datetime=start_datetime,\n            end_datetime=end_datetime,\n            guest_name=guest_name,\n            guest_email=guest_email,\n            guest_phone=guest_phone,\n            guest_count=guest_count,\n            total_price=total_price,\n            special_requests=special_requests,\n            status=models.BookingStatus.confirmed,\n            confirmed_at=datetime.utcnow()\n        )\n\n        self.db.add(booking)\n        self.db.commit()\n        self.db.refresh(booking)\n\n        return booking\n\n    def cancel_booking(\n        self,\n        booking_id: int,\n        user_id: int,\n        reason: str = None\n    ) -> models.Booking:\n        """\uc608\uc57d \ucde8\uc18c"""\n        booking = self.db.query(models.Booking).filter(\n            models.Booking.id == booking_id,\n            models.Booking.user_id == user_id\n        ).first()\n\n        if not booking:\n            raise HTTPException(status_code=404, detail="Booking not found")\n\n        if booking.status in [models.BookingStatus.cancelled, models.BookingStatus.completed]:\n            raise HTTPException(status_code=400, detail="Cannot cancel this booking")\n\n        # \ucde8\uc18c \uc2dc\uac04 \uc81c\ud55c (\uc608: 24\uc2dc\uac04 \uc804\uae4c\uc9c0\ub9cc \ucde8\uc18c \uac00\ub2a5)\n        hours_until = (booking.start_datetime - datetime.now()).total_seconds() / 3600\n        if hours_until < 24:\n            raise HTTPException(\n                status_code=400,\n                detail="Cannot cancel within 24 hours of booking start time"\n            )\n\n        booking.status = models.BookingStatus.cancelled\n        booking.cancelled_at = datetime.utcnow()\n        booking.cancellation_reason = reason\n\n        self.db.commit()\n\n        # \ub300\uae30\uc5f4\uc5d0 \uc788\ub294 \uc0ac\ub78c\ub4e4\uc5d0\uac8c \uc54c\ub9bc\n        self._notify_waitlist(booking)\n\n        return booking\n\n    def _notify_waitlist(self, cancelled_booking: models.Booking):\n        """\ub300\uae30\uc5f4\uc5d0 \uc788\ub294 \uc0ac\ub78c\ub4e4\uc5d0\uac8c \uc54c\ub9bc"""\n        waitlist_entries = self.db.query(models.WaitList).filter(\n            models.WaitList.resource_id == cancelled_booking.resource_id,\n            models.WaitList.notified == False,\n            models.WaitList.desired_start <= cancelled_booking.start_datetime,\n            models.WaitList.desired_end >= cancelled_booking.end_datetime\n        ).all()\n\n        for entry in waitlist_entries:\n            # \uc2e4\uc81c\ub85c\ub294 \uc774\uba54\uc77c/SMS \ubc1c\uc1a1\n            print(f"Notifying user {entry.user_id} about availability")\n            entry.notified = True\n\n        self.db.commit()\n'})}),"\n",(0,o.jsx)(n.h3,{id:"mainpy",children:"main.py"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks\nfrom sqlalchemy.orm import Session\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport models, schemas\nfrom database import engine, get_db\nfrom booking_service import BookingService\nfrom auth import get_current_user\n\nmodels.Base.metadata.create_all(bind=engine)\n\napp = FastAPI(title="Booking System API")\n\n# ==================== \uc790\uc6d0 \uad00\ub9ac ====================\n\n@app.get("/resources", response_model=List[schemas.Resource])\ndef list_resources(\n    type: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    """\uc608\uc57d \uac00\ub2a5\ud55c \uc790\uc6d0 \ubaa9\ub85d"""\n    query = db.query(models.Resource).filter(models.Resource.is_active == True)\n\n    if type:\n        query = query.filter(models.Resource.type == type)\n\n    return query.all()\n\n@app.get("/resources/{resource_id}", response_model=schemas.Resource)\ndef get_resource(resource_id: int, db: Session = Depends(get_db)):\n    """\uc790\uc6d0 \uc0c1\uc138 \uc815\ubcf4"""\n    resource = db.query(models.Resource).filter(\n        models.Resource.id == resource_id\n    ).first()\n\n    if not resource:\n        raise HTTPException(status_code=404, detail="Resource not found")\n\n    return resource\n\n# ==================== \uac00\uc6a9\uc131 \ud655\uc778 ====================\n\n@app.get("/resources/{resource_id}/availability")\ndef check_availability(\n    resource_id: int,\n    date: str,  # YYYY-MM-DD\n    db: Session = Depends(get_db)\n):\n    """\ud2b9\uc815 \ub0a0\uc9dc\uc758 \uc608\uc57d \uac00\ub2a5 \uc2dc\uac04\ub300 \uc870\ud68c"""\n    service = BookingService(db)\n\n    target_date = datetime.strptime(date, "%Y-%m-%d").date()\n    resource = db.query(models.Resource).filter(\n        models.Resource.id == resource_id\n    ).first()\n\n    if not resource:\n        raise HTTPException(status_code=404, detail="Resource not found")\n\n    # \uc6b4\uc601 \uc2dc\uac04 \ud30c\uc2f1\n    open_hour, open_minute = map(int, resource.open_time.split(\':\'))\n    close_hour, close_minute = map(int, resource.close_time.split(\':\'))\n\n    # 30\ubd84 \ub2e8\uc704\ub85c \uac00\uc6a9\uc131 \ud655\uc778\n    available_slots = []\n    current_time = datetime.combine(target_date, datetime.min.time()).replace(\n        hour=open_hour, minute=open_minute\n    )\n    end_of_day = datetime.combine(target_date, datetime.min.time()).replace(\n        hour=close_hour, minute=close_minute\n    )\n\n    while current_time < end_of_day:\n        slot_end = current_time + timedelta(minutes=30)\n\n        try:\n            is_available = service.check_availability(\n                resource_id,\n                current_time,\n                slot_end\n            )\n\n            if is_available:\n                available_slots.append({\n                    "start": current_time.isoformat(),\n                    "end": slot_end.isoformat()\n                })\n        except:\n            pass\n\n        current_time = slot_end\n\n    return {"date": date, "available_slots": available_slots}\n\n# ==================== \uc608\uc57d \uad00\ub9ac ====================\n\n@app.post("/bookings", response_model=schemas.Booking)\ndef create_booking(\n    booking: schemas.BookingCreate,\n    current_user: User = Depends(get_current_user),\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db)\n):\n    """\uc608\uc57d \uc0dd\uc131"""\n    service = BookingService(db)\n\n    db_booking = service.create_booking(\n        resource_id=booking.resource_id,\n        user_id=current_user.id,\n        start_datetime=booking.start_datetime,\n        end_datetime=booking.end_datetime,\n        guest_name=booking.guest_name,\n        guest_email=booking.guest_email,\n        guest_phone=booking.guest_phone,\n        guest_count=booking.guest_count,\n        special_requests=booking.special_requests\n    )\n\n    # \ub9ac\ub9c8\uc778\ub354 \uc608\uc57d (24\uc2dc\uac04 \uc804)\n    background_tasks.add_task(\n        schedule_reminder,\n        db_booking.id,\n        db_booking.start_datetime - timedelta(hours=24)\n    )\n\n    return db_booking\n\n@app.get("/bookings/my", response_model=List[schemas.Booking])\ndef get_my_bookings(\n    status: Optional[str] = None,\n    upcoming: bool = True,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    """\ub0b4 \uc608\uc57d \ubaa9\ub85d"""\n    query = db.query(models.Booking).filter(\n        models.Booking.user_id == current_user.id\n    )\n\n    if status:\n        query = query.filter(models.Booking.status == status)\n\n    if upcoming:\n        query = query.filter(\n            models.Booking.start_datetime >= datetime.now()\n        )\n\n    return query.order_by(models.Booking.start_datetime).all()\n\n@app.put("/bookings/{booking_id}/cancel")\ndef cancel_booking(\n    booking_id: int,\n    reason: Optional[str] = None,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    """\uc608\uc57d \ucde8\uc18c"""\n    service = BookingService(db)\n    booking = service.cancel_booking(booking_id, current_user.id, reason)\n    return {"message": "Booking cancelled", "booking": booking}\n\n@app.post("/bookings/{booking_id}/no-show")\ndef mark_no_show(\n    booking_id: int,\n    db: Session = Depends(get_db)\n):\n    """\ub178\uc1fc \ucc98\ub9ac (\uad00\ub9ac\uc790\uc6a9)"""\n    booking = db.query(models.Booking).filter(\n        models.Booking.id == booking_id\n    ).first()\n\n    if not booking:\n        raise HTTPException(status_code=404, detail="Booking not found")\n\n    # \uc608\uc57d \uc2dc\uc791 \uc2dc\uac04\uc774 \uc9c0\ub0ac\ub294\uc9c0 \ud655\uc778\n    if booking.start_datetime > datetime.now():\n        raise HTTPException(status_code=400, detail="Cannot mark as no-show yet")\n\n    booking.status = models.BookingStatus.no_show\n    db.commit()\n\n    return {"message": "Marked as no-show"}\n\n# ==================== \ub300\uae30\uc5f4 ====================\n\n@app.post("/waitlist")\ndef join_waitlist(\n    waitlist: schemas.WaitListCreate,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    """\ub300\uae30\uc5f4 \ub4f1\ub85d"""\n    entry = models.WaitList(\n        resource_id=waitlist.resource_id,\n        user_id=current_user.id,\n        desired_start=waitlist.desired_start,\n        desired_end=waitlist.desired_end,\n        guest_count=waitlist.guest_count\n    )\n\n    db.add(entry)\n    db.commit()\n\n    return {"message": "Added to waitlist", "position": get_waitlist_position(entry, db)}\n\ndef get_waitlist_position(entry: models.WaitList, db: Session) -> int:\n    """\ub300\uae30\uc5f4 \uc21c\ubc88 \uc870\ud68c"""\n    count = db.query(models.WaitList).filter(\n        models.WaitList.resource_id == entry.resource_id,\n        models.WaitList.created_at < entry.created_at\n    ).count()\n\n    return count + 1\n\n# ==================== \ubc31\uadf8\ub77c\uc6b4\ub4dc \uc791\uc5c5 ====================\n\ndef schedule_reminder(booking_id: int, reminder_time: datetime):\n    """\ub9ac\ub9c8\uc778\ub354 \uc608\uc57d (\uc2e4\uc81c\ub85c\ub294 Celery \ub4f1 \uc0ac\uc6a9)"""\n    # \uc2e4\uc81c\ub85c\ub294 \uc2a4\ucf00\uc904\ub7ec\uc5d0 \ub4f1\ub85d\n    print(f"Reminder scheduled for booking {booking_id} at {reminder_time}")\n\ndef send_reminder():\n    """\ub9ac\ub9c8\uc778\ub354 \ubc1c\uc1a1 (\ud06c\ub860\uc7a1\uc73c\ub85c \uc2e4\ud589)"""\n    from database import SessionLocal\n    db = SessionLocal()\n\n    # 24\uc2dc\uac04 \uc774\ub0b4 \uc608\uc57d\n    tomorrow = datetime.now() + timedelta(hours=24)\n    bookings = db.query(models.Booking).filter(\n        models.Booking.start_datetime <= tomorrow,\n        models.Booking.start_datetime >= datetime.now(),\n        models.Booking.status == models.BookingStatus.confirmed,\n        models.Booking.reminder_sent == False\n    ).all()\n\n    for booking in bookings:\n        # \uc774\uba54\uc77c/SMS \ubc1c\uc1a1\n        print(f"Sending reminder to {booking.guest_email}")\n        booking.reminder_sent = True\n\n    db.commit()\n    db.close()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"-\ud575\uc2ec-\uac1c\ub150",children:"\ud83d\udd11 \ud575\uc2ec \uac1c\ub150"}),"\n",(0,o.jsx)(n.h3,{id:"\uc911\ubcf5-\uc608\uc57d-\ubc29\uc9c0",children:"\uc911\ubcf5 \uc608\uc57d \ubc29\uc9c0"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"SQL \ucffc\ub9ac\ub85c \uc2dc\uac04\ub300 \uacb9\uce68 \ud655\uc778"}),"\n",(0,o.jsx)(n.li,{children:"OR \uc870\uac74\uc73c\ub85c \ubaa8\ub4e0 \uacb9\uce68 \ucf00\uc774\uc2a4 \ucc98\ub9ac"}),"\n",(0,o.jsx)(n.li,{children:"\ud2b8\ub79c\uc7ad\uc158\uc73c\ub85c \ub3d9\uc2dc\uc131 \uc81c\uc5b4"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"\uc6b4\uc601-\uc2dc\uac04-\uac80\uc99d",children:"\uc6b4\uc601 \uc2dc\uac04 \uac80\uc99d"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"\uc790\uc6d0\ubcc4 open_time/close_time \uc124\uc815"}),"\n",(0,o.jsx)(n.li,{children:"\uc608\uc57d \uc2dc\uac04\uc774 \uc6b4\uc601 \uc2dc\uac04 \ub0b4\uc778\uc9c0 \ud655\uc778"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"\ub300\uae30\uc5f4-\uc2dc\uc2a4\ud15c",children:"\ub300\uae30\uc5f4 \uc2dc\uc2a4\ud15c"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"\uc608\uc57d \ubd88\uac00 \uc2dc \ub300\uae30\uc5f4 \ub4f1\ub85d"}),"\n",(0,o.jsx)(n.li,{children:"\ucde8\uc18c \ubc1c\uc0dd \uc2dc \uc790\ub3d9 \uc54c\ub9bc"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"\ub9ac\ub9c8\uc778\ub354",children:"\ub9ac\ub9c8\uc778\ub354"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"BackgroundTasks\ub85c \uc2a4\ucf00\uc904\ub9c1"}),"\n",(0,o.jsx)(n.li,{children:"\uc2e4\uc81c\ub85c\ub294 Celery + Redis \uc0ac\uc6a9 \uad8c\uc7a5"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-\ub2e4\uc74c-\ub2e8\uacc4",children:"\ud83d\udcda \ub2e4\uc74c \ub2e8\uacc4"}),"\n",(0,o.jsxs)(n.p,{children:["\ud83d\udc49 ",(0,o.jsx)(n.a,{href:"./scenario-10-notification-system",children:"\uc54c\ub9bc \uc2dc\uc2a4\ud15c"})]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);